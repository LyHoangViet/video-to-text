import os
import boto3
import base64
import json
import streamlit as st
from typing import List
from botocore.exceptions import ClientError
import tempfile
import cv2
from PIL import Image
import io

# Import t·ª´ module video_processor
from video_processor import VideoProcessor

st.set_page_config(
    page_title="Ph√¢n T√≠ch Video S·∫£n Ph·∫©m V·ªõi Claude",
    page_icon="üîç",
    layout="wide"
)

# Khai b√°o m·∫∑c ƒë·ªãnh cho prompt v√† c√°c th√¥ng s·ªë model
DEFAULT_PROMPT = """D·ª±a v√†o list h√¨nh t·ª´ video n√†y, b·∫°n h√£y:

1. X√°c ƒë·ªãnh t·∫•t c·∫£ c√°c lo·∫°i s·∫£n ph·∫©m kh√°c nhau xu·∫•t hi·ªán trong h√¨nh (d·ª±a v√†o m√†u s·∫Øc bao b√¨, thi·∫øt k·∫ø v√† t√™n s·∫£n ph·∫©m).

2. ƒê·∫øm s·ªë l∆∞·ª£ng s·∫£n ph·∫©m c·ªßa m·ªói lo·∫°i.

3. T·ªïng h·ª£p th√¥ng tin v·ªõi:
   - S·ªë lo·∫°i s·∫£n ph·∫©m kh√°c nhau
   - S·ªë l∆∞·ª£ng c·ªßa m·ªói lo·∫°i
   - T·ªïng s·ªë s·∫£n ph·∫©m
   
4. M√¥ t·∫£ ng·∫Øn g·ªçn ƒë·∫∑c ƒëi·ªÉm nh·∫≠n d·∫°ng ch√≠nh c·ªßa m·ªói lo·∫°i s·∫£n ph·∫©m ƒë·ªÉ ph√¢n bi·ªát."""

DEFAULT_TEMPERATURE = 0.0
DEFAULT_TOP_P = 0.9
DEFAULT_TOP_K = 250
DEFAULT_MAX_TOKENS = 1000

def detect_image_type(file_name: str) -> str:
    """
    Detects the image MIME type based on file extension.
    
    Args:
        file_name: Name of the image file
        
    Returns:
        MIME type string for the image
    """
    extension = os.path.splitext(file_name)[1].lower()
    
    mime_types = {
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".png": "image/png",
        ".gif": "image/gif",
        ".webp": "image/webp",
        ".bmp": "image/bmp"
    }
    
    return mime_types.get(extension, "image/jpeg")

def image_to_base64(image, image_name="frame.jpg"):
    """
    Chuy·ªÉn ƒë·ªïi ·∫£nh (PIL Image ho·∫∑c numpy array) th√†nh chu·ªói base64.
    
    Args:
        image: ·∫¢nh d·∫°ng PIL Image ho·∫∑c numpy array
        image_name: T√™n ·∫£nh ƒë·ªÉ x√°c ƒë·ªãnh ki·ªÉu MIME
        
    Returns:
        Tuple (chu·ªói base64, ki·ªÉu MIME)
    """
    # N·∫øu l√† numpy array (t·ª´ OpenCV), chuy·ªÉn th√†nh PIL Image
    if isinstance(image, (list, tuple, bytes, bytearray)):
        # ƒê√£ l√† bytes ho·∫∑c bytearray
        img_bytes = image
    elif hasattr(image, 'shape'):  # Numpy array
        img_pil = Image.fromarray(image)
        buf = io.BytesIO()
        img_pil.save(buf, format='JPEG')
        img_bytes = buf.getvalue()
    else:  # PIL Image
        buf = io.BytesIO()
        image.save(buf, format='JPEG')
        img_bytes = buf.getvalue()
        
    # Encode base64
    base64_encoded = base64.b64encode(img_bytes).decode('utf-8')
    mime_type = detect_image_type(image_name)
    
    return base64_encoded, mime_type

def analyze_frames_with_claude(frames, prompt: str, temperature: float, top_p: float, top_k: int, max_tokens: int, region_name: str = "us-east-1"):
    """
    Uses Claude 3.7 Sonnet on AWS Bedrock to analyze video frames and count different types of products.
    
    Args:
        frames: List of video frames to analyze
        prompt: Custom prompt for Claude
        temperature: Temperature setting (0-1)
        top_p: Top-p setting (0-1)
        top_k: Top-k setting
        max_tokens: Maximum tokens in response
        region_name: AWS region name where Bedrock is available
        
    Returns:
        Claude's analysis of the video frame content
    """
    
    # Create placeholder for loading indicator
    with st.spinner("Claude ƒëang ph√¢n t√≠ch frames t·ª´ video..."):
        # Read and encode frames
        images = []
        for i, (_, frame) in enumerate(frames):
            # Encode to base64
            image_data, mime_type = image_to_base64(frame, f"frame_{i}.jpg")
                
            images.append({
                "type": "image",
                "source": {
                    "type": "base64",
                    "media_type": mime_type,
                    "data": image_data
                }
            })
        
        # Prepare the message content combining images and prompt
        message_content = images + [{"type": "text", "text": prompt}]
        
        # Prepare the request payload for Bedrock
        payload = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": max_tokens,
            "temperature": temperature,
            "top_p": top_p,
            "top_k": top_k,
            "messages": [
                {
                    "role": "user",
                    "content": message_content
                }
            ]
        }
        
        try:
            # Create a Bedrock Runtime client
            # Use AWS credentials from environment variables or AWS configuration
            bedrock_runtime = boto3.client(
                service_name="bedrock-runtime",
                region_name=region_name
            )
            
            # Invoke the model on Bedrock
            response = bedrock_runtime.invoke_model(
                modelId="us.anthropic.claude-3-7-sonnet-20250219-v1:0",
                body=json.dumps(payload)
            )
            
            # Parse and return the response
            response_body = json.loads(response["body"].read())
            return response_body["content"][0]["text"]
        
        except ClientError as e:
            return f"L·ªói khi g·ªçi Bedrock model: {str(e)}"
        except Exception as e:
            return f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}"

def main():
    # App title
    st.title("Ph√¢n T√≠ch Video S·∫£n Ph·∫©m V·ªõi Claude 3.7 Sonnet")
    
    # Information block
    st.info("""
    ·ª®ng d·ª•ng n√†y s·ª≠ d·ª•ng Claude 3.7 Sonnet tr√™n AWS Bedrock ƒë·ªÉ ph√¢n t√≠ch video s·∫£n ph·∫©m.
    T·∫£i l√™n video v√† ch·ªçn ph∆∞∆°ng ph√°p tr√≠ch xu·∫•t frames ƒë·ªÉ Claude ph√¢n t√≠ch s·∫£n ph·∫©m.
    """)
    
    # Sidebar for AWS configuration and model parameters
    st.sidebar.title("C·∫•u h√¨nh")
    
    # AWS Region selection
    aws_region = st.sidebar.selectbox(
        "Ch·ªçn AWS Region:",
        ["us-east-1", "us-west-2", "eu-central-1", "ap-southeast-1"],
        index=0
    )
    
    # Option to use custom AWS credentials
    st.sidebar.subheader("AWS Credentials")
    use_custom_creds = st.sidebar.checkbox("S·ª≠ d·ª•ng AWS Credentials t√πy ch·ªânh", value=False)
    
    if use_custom_creds:
        aws_access_key = st.sidebar.text_input("AWS Access Key ID", type="password")
        aws_secret_key = st.sidebar.text_input("AWS Secret Access Key", type="password")
        
        # Set environment variables if provided
        if aws_access_key and aws_secret_key:
            os.environ["AWS_ACCESS_KEY_ID"] = aws_access_key
            os.environ["AWS_SECRET_ACCESS_KEY"] = aws_secret_key
    
    # Sidebar info about AWS credentials
    st.sidebar.markdown("""
    #### L∆∞u √Ω:
    N·∫øu kh√¥ng nh·∫≠p AWS credentials t√πy ch·ªânh, ·ª©ng d·ª•ng s·∫Ω s·ª≠ d·ª•ng:
    1. Credentials t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
    2. Ho·∫∑c t·ª´ file `~/.aws/credentials`
    3. Ho·∫∑c t·ª´ IAM Role (n·∫øu ch·∫°y tr√™n AWS)
    """)
    
    # Model Parameters section
    st.sidebar.subheader("Tham S·ªë Model")
    
    temperature = st.sidebar.slider(
        "Temperature:", 
        min_value=0.0,
        max_value=1.0,
        value=DEFAULT_TEMPERATURE,
        step=0.05,
        help="Ki·ªÉm so√°t m·ª©c ƒë·ªô ng·∫´u nhi√™n trong ƒë·∫ßu ra. Gi√° tr·ªã 0 s·∫Ω cho k·∫øt qu·∫£ nh·∫•t qu√°n, gi√° tr·ªã cao h∆°n t·∫°o nhi·ªÅu bi·∫øn th·ªÉ."
    )
    
    top_p = st.sidebar.slider(
        "Top P:",
        min_value=0.0,
        max_value=1.0,
        value=DEFAULT_TOP_P,
        step=0.05,
        help="Ki·ªÉm so√°t ƒëa d·∫°ng th√¥ng qua nucleus sampling. 1.0 = kh√¥ng h·∫°n ch·∫ø, 0.5 = ch·ªâ xem x√©t tokens trong top 50% x√°c su·∫•t."
    )
    
    top_k = st.sidebar.slider(
        "Top K:",
        min_value=0,
        max_value=500,
        value=DEFAULT_TOP_K,
        step=10,
        help="Gi·ªõi h·∫°n s·ªë tokens ƒë∆∞·ª£c xem x√©t khi t·∫°o ƒë·∫ßu ra. 0 = kh√¥ng s·ª≠ d·ª•ng top_k."
    )
    
    max_tokens = st.sidebar.slider(
        "Max Tokens:",
        min_value=100,
        max_value=4000,
        value=DEFAULT_MAX_TOKENS,
        step=100,
        help="ƒê·ªô d√†i t·ªëi ƒëa c·ªßa ph·∫£n h·ªìi ƒë∆∞·ª£c t·∫°o ra."
    )
    
    # Prompt configuration section
    st.sidebar.subheader("T√πy Ch·ªânh Prompt")
    
    # Option to use custom prompt
    use_custom_prompt = st.sidebar.checkbox("S·ª≠ d·ª•ng prompt t√πy ch·ªânh", value=False)
    
    if use_custom_prompt:
        prompt = st.sidebar.text_area("Nh·∫≠p prompt c·ªßa b·∫°n:", DEFAULT_PROMPT, height=300)
    else:
        prompt = DEFAULT_PROMPT
        st.sidebar.markdown("*ƒêang s·ª≠ d·ª•ng prompt m·∫∑c ƒë·ªãnh*")
    
    # Main content area
    # File uploader for video
    st.subheader("T·∫£i l√™n video s·∫£n ph·∫©m")
    uploaded_video = st.file_uploader(
        "Ch·ªçn file video (MP4, MOV, AVI, etc.)",
        type=["mp4", "mov", "avi", "mkv", "wmv"],
    )
    
    # Video frame extraction settings
    st.subheader("C√†i ƒë·∫∑t tr√≠ch xu·∫•t frames")
    
    extraction_method = st.radio(
        "Ph∆∞∆°ng ph√°p tr√≠ch xu·∫•t frames:",
        ["ƒê·ªÅu ƒë·∫∑n theo s·ªë l∆∞·ª£ng", "Theo kho·∫£ng th·ªùi gian", "T·ª± ƒë·ªông ph√°t hi·ªán keyframes"]
    )
    
    # Show different settings based on extraction method
    if extraction_method == "ƒê·ªÅu ƒë·∫∑n theo s·ªë l∆∞·ª£ng":
        num_frames = st.slider(
            "S·ªë l∆∞·ª£ng frames c·∫ßn tr√≠ch xu·∫•t:",
            min_value=5,
            max_value=30,
            value=10,
            step=1
        )
    elif extraction_method == "Theo kho·∫£ng th·ªùi gian":
        interval_seconds = st.slider(
            "Kho·∫£ng th·ªùi gian gi·ªØa c√°c frames (gi√¢y):",
            min_value=0.5,
            max_value=10.0,
            value=2.0,
            step=0.5
        )
    else:  # T·ª± ƒë·ªông ph√°t hi·ªán keyframes
        threshold = st.slider(
            "Ng∆∞·ª°ng ph√°t hi·ªán keyframes:",
            min_value=0.01,
            max_value=0.5,
            value=0.1,
            step=0.01,
            help="Gi√° tr·ªã c√†ng th·∫•p, c√†ng nhi·ªÅu frames ƒë∆∞·ª£c ph√°t hi·ªán"
        )
        max_keyframes = st.slider(
            "S·ªë l∆∞·ª£ng keyframes t·ªëi ƒëa:",
            min_value=5,
            max_value=30,
            value=15,
            step=1
        )
    
    # Show video and process it
    if uploaded_video:
        st.video(uploaded_video)
        
        # Button to extract frames and analyze
        if st.button("Tr√≠ch xu·∫•t frames v√† ph√¢n t√≠ch", type="primary"):
            # Process the video to extract frames
            video_processor = VideoProcessor(uploaded_video)
            video_info = video_processor.get_video_info()
            
            # Display video info
            st.subheader("Th√¥ng tin video")
            st.write(f"T√™n file: {video_info['filename']}")
            st.write(f"ƒê·ªô ph√¢n gi·∫£i: {video_info['resolution'][0]} x {video_info['resolution'][1]}")
            st.write(f"FPS: {video_info['fps']:.2f}")
            st.write(f"Th·ªùi l∆∞·ª£ng: {video_info['duration']:.2f} gi√¢y")
            st.write(f"T·ªïng s·ªë frames: {video_info['frame_count']}")
            
            # Extract frames based on selected method
            with st.spinner("ƒêang tr√≠ch xu·∫•t frames t·ª´ video..."):
                if extraction_method == "ƒê·ªÅu ƒë·∫∑n theo s·ªë l∆∞·ª£ng":
                    frames = video_processor.extract_frames_uniform(num_frames)
                    st.write(f"ƒê√£ tr√≠ch xu·∫•t {len(frames)} frames ph√¢n b·ªë ƒë·ªÅu")
                elif extraction_method == "Theo kho·∫£ng th·ªùi gian":
                    frames = video_processor.extract_frames_interval(interval_seconds)
                    st.write(f"ƒê√£ tr√≠ch xu·∫•t {len(frames)} frames (m·ªói {interval_seconds} gi√¢y)")
                else:  # T·ª± ƒë·ªông ph√°t hi·ªán keyframes
                    frames = video_processor.extract_frames_keyframes(threshold, max_keyframes)
                    st.write(f"ƒê√£ ph√°t hi·ªán v√† tr√≠ch xu·∫•t {len(frames)} keyframes")
            
            # Display extracted frames
            st.subheader("Frames ƒë√£ tr√≠ch xu·∫•t")
            
            # Create columns to display frames
            num_cols = 4  # Number of columns in the grid
            cols = st.columns(num_cols)
            
            # Hi·ªÉn th·ªã c√°c frames ƒë√£ tr√≠ch xu·∫•t
            extracted_frames = []
            for i, frame in enumerate(frames):
                col_idx = i % num_cols
                with cols[col_idx]:
                    # Hi·ªÉn th·ªã frame
                    st.image(
                        frame.image, 
                        caption=f"Frame {frame.frame_number} (t={frame.timestamp:.2f}s)", 
                        use_column_width=True
                    )
                    # L∆∞u ƒë·ªÉ ph√¢n t√≠ch
                    extracted_frames.append((i, frame.image))
            
            # Ph√¢n t√≠ch frames b·∫±ng Claude
            if extracted_frames:
                # Call Claude via AWS Bedrock
                result = analyze_frames_with_claude(
                    extracted_frames, 
                    prompt, 
                    temperature, 
                    top_p, 
                    top_k, 
                    max_tokens, 
                    aws_region
                )
                
                # Display results
                st.subheader("K·∫øt qu·∫£ ph√¢n t√≠ch")
                st.markdown(result)
                
                # Option to download as text file
                if result:
                    # Create download button for the result
                    st.download_button(
                        label="T·∫£i k·∫øt qu·∫£ v·ªÅ (TXT)",
                        data=result,
                        file_name="ket_qua_phan_tich.txt",
                        mime="text/plain"
                    )
                    
                    # Save prompt used for reference
                    st.download_button(
                        label="T·∫£i prompt ƒë√£ s·ª≠ d·ª•ng (TXT)",
                        data=prompt,
                        file_name="prompt_da_su_dung.txt",
                        mime="text/plain"
                    )
    else:
        st.write("üëÜ H√£y t·∫£i l√™n video ƒë·ªÉ ph√¢n t√≠ch")

if __name__ == "__main__":
    main()